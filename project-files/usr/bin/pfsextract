#!/bin/sh
#VERSION 3.3
. /usr/bin/pfsfunc

HLP(){
[ "`echo $LANG| egrep '^ru_RU'`" ] || return
echo "\
pfsextract извлекает отдельные модули из составных модулей.pfs.
Использование:

    pfsextract /file.pfs [параметры] - создать каталог «/file» с отдельными модулями.pfs из «/file.pfs»
    pfsextract -d /file.pfs [параметры] - создать каталог «/file» с отдельными каталогами, в каждый из которых распакованы отдельные модули из «/file.pfs»
    pfsextract /file.pfs /catalog [параметры] - создать в каталоге «/catalog» отдельные модули.pfs из «/file.pfs». «/catalog» должен быть пустым.
    pfsextract /file.pfs /catalog -p pack_1 pack_2 [параметры] - создать в каталоге «/catalog» отдельные файлы .pfs только из модулей «pack_1» и «pack_2», если модули с такими названиями содержатся в файле «/file.pfs» (использование «-p pack_1 pack_2» допустимо и без указания «/catalog»).

Параметры (ключи):

    -no-progress - не показывать строку прогресса.
    -f  - быстрая компрессия (размер .pfs больше, но создается быстрее).
" >&2 ;exit 1
}

[ "$1" = "-d" ] && d=1 && shift
[ "$1" ] || HLP
allow_only_root

#check kernel
checksfsxzb >/dev/null 2>&1
exitmsg "Kernel is not support squashfs/aufs" $?

wh="-regex -e ".wh..wh.""

ML(){
n="$(mkaufs || exitmsg "mkaufs error" 2)"
nn="$(echo "$n" | sed -n 's/^.*\([0-9]\)$/\1/p')"
[ -d "$n" ] || exitmsg "error mounting aufs" 3
}

argslist="$@"
if  echo $argslist |grep -q "\-*comp .*" ; then
	compression="$(echo $@ |sed 's/^.*\-*comp//')"
	argslist="$(echo $@ |sed 's/\-*comp.*$//')"
fi

#get opts
sourcelist=""
for arg in $argslist
do
  case "${arg}" in
    "-p" | "--packages" ) list="yes";;
#    "-o" | "--out-file") onuserout="on";;
    "-h" | "--help")  HLP ;exit 1;;
    "-q" | "--quiet" ) devnull='>/dev/null' ;;
    "-no-progress" | "--no-progress") noprogress="-no-progress";;
    "-processors" | "--processors" ) numproc="on";;
#    "-w") wh="-regex -e ".wh..wh."";;
    "-f" | "--fast" | "-g" ) [ "$compression_fast" ] && compression="$compression_fast" || compression="gzip";;
    "-"*[A-Za-z]*) echo "$(basename "$0"): invalid option -- '$(echo ${arg} | tr -d '-')'" >&2; HLP; exit 1;;
    *) if [ "${usepkname}" = "on" ]; then packname="${arg}"
       elif [ "${onuserout}" = "on" ]; then userout="${arg}"
       elif [ "${numproc}" = "on" ]; then useproc="-processors ${arg}"
       else sourcelist="${sourcelist} ${arg}"; fi
       onuserout="off"; usepkname="off"; usindlib="off"; numproc="off";;
  esac
done

[ "$(fs_type $1)" == "squashfs" ] || exitmsg "File '${1}' is not squashfs" 1
p="`basename "$1"`"
mm="/$SYSMNT/bundles1/$p/etc/packages/mount/"
dir="`basename "$1" .pfs`" && pfs="$1" && shift
[ "$1" ] && dir="$1"  && shift
[ -d "${dir}" ] && exitmsg "output dirrectory '$dir' exists" 1
[ "$list" ] && shift 

#no component-pfs or simple squashfs
if [ "`unsquashfs -l ${pfs} |grep ${PFSDIR}/mount |egrep '.files$' |wc -l`" -lt 2 ];then
    [ "$d$list" ] && exitmsg "File '${pfs}' is not component-pfs. Use 'unsquashfs ${pfs}'" 1
    eval unsquashfs -d "${dir}" "${pfs}" $noprogress $useproc "$devnull"  && exit 0
	exitmsg "unsquashfs error" $?
fi

	mkdir -p "$dir" && pfsinfo "$pfs" |while read m ;do
    [ "$list" ] && { [ "`echo "$@" |grep "$m"`" ] || continue ; }
    ML "$pfs"
    eval addlayer "$nn" "$pfs" "$devnull" || exitmsg "can't insert layer to aufs $nn" 5
    cat "/$SYSMNT/bundles$nn/$p/etc/packages/mount/$m/pfs.files" | while read F; do 
	touch "/$SYSMNT/aufs$nn$F"
    done

    emp="/$SYSMNT/bundles$nn/$p/etc/packages/mount/$m/pfs.dirs.empty"
    [ -f "$emp" ] && cat "$emp" | while read F; do 
	touch "/$SYSMNT/aufs$nn$F"
    done

    mklist "/$SYSMNT/changes$nn" "/$SYSMNT/changes$nn" "$m" 
    if [ "$d" ];then	
	mkdir -p "$dir/$m" && mv "/$SYSMNT/changes$nn"/* "$dir/$m"
    else
	mksqmod "/$SYSMNT/changes$nn" "$dir/$m.pfs"
    fi
    delaufs $nn
done 
