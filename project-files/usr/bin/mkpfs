#!/bin/sh
#VERSION 3.4
. /usr/bin/pfsfunc

#aliases
case $1 in
 -d | --dir )
    m="$(find "$2" -maxdepth 1 -mindepth 1 -type d )"
    [ "$m" ] || exitmsg "no directory in '$2'" 1
    $0 $m -o "$2".pfs ; exit $?
    ;;
 -m | --mod )
    m="$(find "$2" -maxdepth 1 -mindepth 1 -type f |egrep '.pfs$|.xzm$|.sfs$|.squashfs$')"
    [ "$m" ] || exitmsg "no modules in '$2'" 1
    $0 $m -o "$2".pfs ; exit $?
    ;;
 esac

MKM(){
#make module
eval mksquashfs "${1}" "${2}" -comp ${compression} -noappend ${noprogress} ${useproc} $wh $devnull
exitmsg "error create squashfs module" $?
}

#help
HLP(){
echo "Usage: $0 <list of sources> -o out.pfs"
echo "Examples:"
echo "$0 ./dir 			-make dir.pfs from dir"
echo "$0 1.pfs 2.pfs -o 3.pfs	-collect 1.pfs and 2.pfs to contaner 3.pfs"
echo "$0 * -o ./big.pfs		-collect all dirs and squashfs modules from current dir to big.pfs" 
echo
echo "Параметры (ключи):"
echo "	-o / --out-file - указывает название выходного файла .pfs."
echo "	-w - не включать AUFS тени."
echo "	-f / --fast - быстрая компрессия (размер .pfs больше, но создается быстрее)."
echo "	-comp / параметры для mksquashfs, компрессия размер блока и проч."
echo "Алиасы (сокращения):"
echo " -d | --dir - Только каталоги"
echo "	$(basename $0) -d dir ---> $(basename $0)" '$(find dir -maxdepth 1 -mindepth 1 -type d ) -o dir.pfs'
echo " -m | --mod - Только модули"
echo "	$(basename $0) -m dir ---> $(basename $0)" '$(find dir -maxdepth 1 -mindepth 1 -type f ) -o dir.pfs'
exit 1
}

[ "$1" ] || HLP
allow_only_root

#check kernel
checksfsxzb >/dev/null 2>&1
exitmsg "Kernel is not support squashfs/aufs" $?

#parsing for "-comp" arg
argslist="$@"
if  echo $argslist |grep -q "\-*comp .*" ; then
	compression="$(echo $@ |sed 's/^.*\-*comp//')"
	argslist="$(echo $@ |sed 's/\-*comp.*$//')"
fi

#get opts
sourcelist=""
for arg in $argslist
do
  case "${arg}" in
    "-o" | "--out-file") onuserout="on";;
    "-h" | "--help")  HLP ;exit 1;;
    "-q" | "--quiet" ) devnull='>/dev/null' ;;
    "-no-progress" | "--no-progress") noprogress="-no-progress";;
    "-processors" | "--processors" ) numproc="on";;
    "-w") wh="-regex -e ".wh..wh."";;
    "-f" | "--fast" | "-g" ) [ "$compression_fast" ] && compression="$compression_fast" || compression="gzip";;
    "-"*[A-Za-z]*) echo "$(basename "$0"): invalid option -- '$(echo ${arg} | tr -d '-')'" >&2; HLP; exit 1;;
    *) if [ "${usepkname}" = "on" ]; then packname="${arg}"
       elif [ "${onuserout}" = "on" ]; then userout="${arg}"
       elif [ "${numproc}" = "on" ]; then useproc="-processors ${arg}"
       else sourcelist="${sourcelist} ${arg}"; fi
       onuserout="off"; usepkname="off"; usindlib="off"; numproc="off";;
  esac
done

[ "${userout}" = "" ] && userout="./$(basename $(echo $sourcelist | awk '{print $1}')).pfs"

#1 dir
if [ -d $sourcelist 2>/dev/null ];then
    [ ! "`ls $sourcelist`" ] && exitmsg "directory '$sourcelist' empty" 1
    mklist $sourcelist && MKM $sourcelist "${userout}" && exit 0 || exitmsg "mkpfs error" 2
fi

#test sources, source must be dir or squashfs module
for source in $sourcelist ;do
	[ -d $source ] && continue
	[ "$(fs_type $source)" == "squashfs" ] && continue
	exitmsg "Type of source \"$source\" is not correct" 2
done	

[ -d "$sourcelist" ] && { ls "$sourcelist" 2>/dev/null || exitmsg "\"`echo $sourcelist`\" is empty" 2 ; }

#make root aufs
n="$(mkaufs || exitmsg "mkaufs error" 2)"
#nn="`echo "$n" |sed 's#/'$SYSMNT'/aufs##'`" Эта не работает у меня
nn="$(echo "$n" | sed -n 's/^.*\([0-9]\)$/\1/p')"
[ -d "$n" ] || exitmsg "error mounting aufs" 3

#add sources as aufs layers
for  i in $sourcelist ;do
    eval addlayer "$nn" "$i" "$devnull" || exitmsg "can't insert layer to aufs $nn" 5
    [ -d "$i" ] && mklist "$i" "$n"
done 
bundles=$(find $(echo $n |sed 's:aufs:bundles:') -maxdepth 1 -mindepth 1 -type d 2>/dev/null)

#mklist for modules
for i in $bundles ;do
	name="$(basename "${i%.*}")" #без расширения
	mklist "$i" "$n" "$name"
done 

MKM "${n}" "${userout}"
delaufs "$nn" && exit 0 || exitmsg "delaufs error" $?
